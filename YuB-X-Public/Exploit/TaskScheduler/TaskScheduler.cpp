#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/Environment/Environment.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>

void TaskScheduler::SetProtoCapabilities(Proto* Proton, uintptr_t* Capabilities)
{
    Proton->userdata = Capabilities;
    for (int i = 0; i < Proton->sizep; ++i)
    {
        SetProtoCapabilities(Proton->p[i], Capabilities);
    }
}

void TaskScheduler::SetThreadCapabilities(lua_State* L, int Level, uintptr_t Capabilities)
{
    *reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(L->userdata) + Offsets::ExtraSpace::Capabilities) = Capabilities;
    *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(L->userdata) + Offsets::ExtraSpace::Identity) = Level;
}

uintptr_t TaskScheduler::GetDataModel()
{
	uintptr_t FakeDataModel = *reinterpret_cast<uintptr_t*>(Offsets::DataModel::FakeDataModelPointer);
    uintptr_t DataModel = *reinterpret_cast<uintptr_t*>(FakeDataModel + Offsets::DataModel::FakeDataModelToDataModel);

	return DataModel;
}

uintptr_t TaskScheduler::GetScriptContext(uintptr_t DataModel)
{
    uintptr_t Children = *reinterpret_cast<uintptr_t*>(DataModel + Offsets::DataModel::Children);
	uintptr_t ScriptContext = *reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(Children) + Offsets::DataModel::ScriptContext);

    return ScriptContext;
}

lua_State* TaskScheduler::DecryptLuaState(uintptr_t ScriptContext)
{
    *reinterpret_cast<BOOLEAN*>(ScriptContext + 0x7E8) = TRUE;

    auto Address = ScriptContext + 0x1F8;
    auto EncryptedState = reinterpret_cast<uint32_t*>(Address);

    uint32_t Low = EncryptedState[0] - static_cast<uint32_t>(Address);
    uint32_t High = EncryptedState[1] - static_cast<uint32_t>(Address);
    return reinterpret_cast<lua_State*>((static_cast<uint64_t>(High) << 32) | Low);
}

int ScriptsHandler(lua_State* L)
{
    if (!SharedVariables::ExecutionRequests.empty())
    {
        Execution::ExecuteScript(SharedVariables::ExploitThread, SharedVariables::ExecutionRequests.front());
        SharedVariables::ExecutionRequests.erase(SharedVariables::ExecutionRequests.begin());
    }

    return 0;
}

void SetupExecution(lua_State* L)
{
    lua_getglobal(L, "game");
    lua_getfield(L, -1, "GetService");
    lua_pushvalue(L, -2);

    lua_pushstring(L, "RunService");
    lua_pcall(L, 2, 1, 0);

    lua_getfield(L, -1, "Stepped");
    lua_getfield(L, -1, "Connect");
    lua_pushvalue(L, -2);

    lua_pushcclosure(L, ScriptsHandler, nullptr, 0);
    lua_pcall(L, 2, 0, 0);
    lua_pop(L, 2);
}

bool TaskScheduler::SetupExploit()
{
    uintptr_t DataModel = TaskScheduler::GetDataModel();
	uintptr_t ScriptContext = TaskScheduler::GetScriptContext(DataModel);
	lua_State* RobloxState = TaskScheduler::DecryptLuaState(ScriptContext);

    SharedVariables::ExploitThread = lua_newthread(RobloxState);
	TaskScheduler::SetThreadCapabilities(SharedVariables::ExploitThread, 8, MaxCapabilities);
	Environment::SetupEnvironment(SharedVariables::ExploitThread);
    luaL_sandboxthread(SharedVariables::ExploitThread);
    SetupExecution(SharedVariables::ExploitThread);

    return true;
}

void TaskScheduler::RequestExecution(std::string script)
{
    SharedVariables::ExecutionRequests.push_back(script);
}
